\subsection{Game}

The environment of the game is divided into a $16x12$ grid. The players can move from one tile
to the next.

\subsubsection{Main program}

The main program does three things, it setup the environment, runs the main loop and tearsdown the environment.

The setup code consists of opening the led-, button and screen driver. The audio driver is opened every
time a sound is played.
\begin{lstlisting}
  ButtonInit();
  LedInit();

  Screen screen = ScreenNew(320, 240);
  Canvas canvas = CanvasNew( &screen );

  // Init game
  Controller ctrl = ControllerNew( &canvas );
  onGameInit( &ctrl );
\end{lstlisting}
When the devices are opened it starts up the game controller.

The game is event based and within one single thread. The main loop has three responsabilities.
\begin{enumerate}
\item Check if the game is over
\item Emit a tick every 20000th loop
\item Pull the button driver (which emits events when buttons are down)
\end{enumerate}
\begin{lstlisting}
  while(ctrl.running) {

    if ( tick_delay++ == 20000 ) {
      tick_delay = 0;
      onTick( &ctrl );
    }

    ButtonPoll();

  }
\end{lstlisting}

When the main loop ends the resources used by the game is closed.
\begin{lstlisting}
  onGameExit( &ctrl );

  ButtonDestroy();
  LedDestroy();
  ScreenDestroy( &screen );
\end{lstlisting}

\subsubsection{Button}
As a we were planning to implement an interrupt driven button driver the game design
was written with this in mind. Our polling based solution tries to emulate an interrupt
driven driver by emitting events when buttons are pushed.

\begin{lstlisting}
  void ButtonPoll( void ) {

    static uint8_t last = 0;
    uint8_t buttons;
    read( _fd, &buttons, 1);

    if (buttons != last) {

      switch (buttons) {

	case 1:	callbacks[0](); break;
	case 2:	callbacks[1](); break;
	case 4:	callbacks[2](); break;
	case 8:	callbacks[3](); break;
	case 16:	callbacks[4](); break;
	case 32:	callbacks[5](); break;
	case 64:	callbacks[6](); break;
	case 128: callbacks[7](); break;

      }
      last = buttons;
    }
  }
\end{lstlisting}
The polling method reads the button state and calls callback functions when one button
is pressed. It hides the similar states and only emits events when the state changes.

\subsubsection{Game Controller}
The {\bf Controller} object receives events from the main program, button module and it self.
It decides how to react by quering the game models ({\bf Field}, {\bf Cannon} and {\bf Tank})
and performs actions on the models, the {\bf Canvas}, the leds and audio device.

From the main program the {\bf Controller} receives the {\bf onGameInit} and {\bf onGameExit} events.
The first of these starts the game and emits the {\bf onGameStart} event.
\begin{lstlisting}
  void onGameInit( Controller *ctrl ) {

    Canvas *canvas = ctrl->canvas;

    CanvasAdd( canvas, &ctrl->field );
    CanvasAdd( canvas, &ctrl->cannon );
    CanvasAdd( canvas, &ctrl->tank );

    ControllerUpdateScore( ctrl );

    CanvasPaint( canvas );

    onGameStart( ctrl );
  }
\end{lstlisting}

The second takes care of showing the end score and playing the exit music
\begin{lstlisting}
  void onGameExit ( Controller *ctrl ) {
    AudioPlay( "./data/gameexit.wav" );
    Image *img;
    if (ctrl->winner == A) {
      img = ImageNew("./data/playerawins_go.bmp", 0, 0);
    } else if (ctrl->winner == B) {
      img = ImageNew("./data/playerbwins_go.bmp", 0, 0);
    }
    // show exit splash
    CanvasAdd( ctrl->canvas, img );
    CanvasPaint( ctrl->canvas );

    sleep( 3 );
  }
\end{lstlisting}

From the buttons the {\bf Controller} receives three events. These are: {\bf onTankMove},
{\bf onCannonAim} and {\bf onCannonFire}.

The {\bf onTankMove} method checks if the tank can move to the requested square. If it
can it ask the Tank object to move there and tells the Canvas that is has to repaint itself.
It then checks if the Cannon has been hit, in that case it emits the {\bf onCannonHit} event.
\begin{lstlisting}
  bool onTankMove ( Controller *ctrl, int dx, int dy ) {

    if ( canMove( ctrl, ctrl->tank.x, ctrl->tank.y, dx, dy ) ) {

      TankMove(&ctrl->tank, dx, dy);
      CanvasPaint( ctrl->canvas);
      if ( CannonIsOn( &ctrl->cannon, ctrl->tank.x, ctrl->tank.y ) ) {
	onCannonHit( ctrl );
      }
      return true;
    }
    return false;
  }
\end{lstlisting}

When the {\bf onCannonAim} event occurs the controller checks if the cannon can move its
aim the the desired cell. If so it tells the cannon to move its aim and the canvas to update
the screen.

\begin{lstlisting}
  bool onCannonAim ( Controller *ctrl, int dx, int dy ) {

    if ( CheckBounds( ctrl, ctrl->cannon.aimx, ctrl->cannon.aimy, dx, dy ) ) {
      CannonAim( &ctrl->cannon, dx, dy );
      CanvasPaint( ctrl->canvas );
      return true;
    }
    return false;
  }
\end{lstlisting}

On the {\bf onCannonFire} event, the {\bf Controller} start by asking the audio module to play the
sound {\it explosion}. Then it notifies the Field that the current position of the {\bf Cannon}s aim
has been hit. After that it ask the {\bf Canvas} to update the screen and lastly it checks if the
tank was hit. If so it emits the {\bf onTankHit} event.
\begin{lstlisting}
  void onCannonFire ( Controller *ctrl ) {

    AudioPlay( "./data/explosion.wav" );

    int x = ctrl->cannon.aimx;
    int y = ctrl->cannon.aimy;

    FieldHit( &ctrl->field, x, y );
    CanvasPaint( ctrl->canvas);

    if (TankIsOn( &ctrl->tank, x, y )) {
      onTankHit( ctrl );
    }

  }
\end{lstlisting}

When either the {\bf Tank} or {\bf Cannon} has been hit the round is over. This is
taken care by the {\bf onRoundOver} method.
\begin{lstlisting}
  void onRoundOver ( Controller *ctrl ) {

    if ( ctrl->tank.health == 0 || ctrl->cannon.health == 0 ) {

      onGameOver( ctrl );

    } else {
      Image *img;
      AudioPlay( "./data/win.wav" );
      if (ctrl->winner == A) {
	img = ImageNew("./data/playerawin.bmp", 0, 0);
      } else if (ctrl->winner == B) {
	img = ImageNew("./data/playerbwin.bmp", 0, 0);
      } else {
	assert(false);
      }

      CanvasAdd( ctrl->canvas, img );
      CanvasPaint( ctrl->canvas );
      sleep( 2 );

      CanvasRemove( ctrl->canvas, img );
      CanvasPaint( ctrl->canvas );

      onRoundStart( ctrl );
    }

  }
\end{lstlisting}

It makes sure that the game is not over, if it is it emits the {\bf onGameOver} event which
terminates the game. If not it plays the asks the audio module to play the win sound and show the
appropiate win screen. At the end it starts the next round by emitting the {\bf onRoundStart} event.
This event resets the player positions and field and calls the {\bf CpntrollerUpdateScore} method
which updates the led lights with the current state of the game.
\begin{lstlisting}
  void ControllerUpdateScore( Controller *ctrl ) {

    int cannon_health = ctrl->cannon.health;
    int tank_health = ctrl->tank.health;

    printf("%d %d\n", cannon_health, tank_health);
    uint8_t val = 0;

    if (tank_health == 1) {
      val = 1;
    } else if (tank_health == 2) {
      val = 3;
    } else if (tank_health == 3) {
      val = 7;
    } else if (tank_health == 4) {
      val = 15;
    }

    if (cannon_health == 1) {
      val |= 0x80;
    } else if (cannon_health == 2) {
      val |= 0xC0;
    } else if (cannon_health == 3) {
      val |= 0xE0;
    } else if (cannon_health == 4) {
      val |= 0xF0;
    }
    LedWrite( val );
  }
\end{lstlisting}
The leds are used to indicate how many lifes each player has remaining. A player loses one life each
time she loses one round.

The last interesting event on the {\bf Controller} is the {\bf onTick} event. As mentioned earlier
the main loop emits an tick on every 20000th iteration. This event enables us to make animations.
The {\bf Controller} passes this event on to anyone needing to animate something, in our case the
{\bf Field} model animates explosions.
\begin{lstlisting}
void onTick ( Controller *ctrl ) {
  FieldIncreaseExplosionState( &ctrl->field );
  CanvasPaint( ctrl->canvas );
}
\end{lstlisting}


\subsubsection{Tank}
The {\bf Tank} model is responsible for holding the state of the Tank player. And for drawing the
tank on the screen. It inherits the {\bf Shape} structure from the graphics package and delegates
the actual drawing to the {\bf Image} class. It contains four different pictures and choses the
right one given its direction. It has a {\bf TankMove} and {\bf TankOnGameStart} method which are
called by the {\bf Controller} class in order to change its state. It also has a {\bf TankIsOn}
method to allow the {\bf Controller} to query its location.

\begin{lstlisting}
bool TankMove( Tank *tank, int dx, int dy ) {

  if (dx == 1) { tank->direction = E; }
  else if (dx == -1) { tank->direction = W; }
  else if (dy == 1) { tank->direction = S; }
  else if (dy == -1) { tank->direction = N; }

  tank->x += dx;
  tank->y += dy;

  return true;

}
\end{lstlisting}
\subsubsection{Cannon}
The {\bf Cannon} model is similar to {\bf Tank} model. It also delegate it drawing work to the {\bf
  Image} class.

\begin{lstlisting}
  static void paint ( Shape *shape, Screen *screen ) {

    Cannon *cannon = (Cannon*)shape;

    if (cannon->angle == 0) {
      cannon->image_0->paint( cannon->image_0, screen );
    } else if (cannon->angle == 30) {
      cannon->image_30->paint( cannon->image_30, screen );
    } else if (cannon->angle == 45) {
      cannon->image_45->paint( cannon->image_45, screen );
    } else if (cannon->angle == 60) {
      cannon->image_60->paint( cannon->image_60, screen );
    } else if (cannon->angle == 90) {
      cannon->image_90->paint( cannon->image_90, screen );
    }
    cannon->aim_image->x = cannon->aimx * 20;
    cannon->aim_image->y = cannon->aimy * 20;
    cannon->aim_image->paint( cannon->aim_image, screen );

  }
\end{lstlisting}
The {\bf Cannon} model paint both the cannon and the crosshair.

\subsubsection{Field}
The {\bf Field} model is also build on the same pattern as the previous discussed models. The only
thing that separates the model is the animation it does. It receives the tick event from the {\bf
  Controller} and changes the image for explosion on every tick.
\begin{lstlisting}
void FieldIncreaseExplosionState( Field *field ) {
  field->explosion_state++;
  if (field->explosion_state >= 16) {
    field->explosion_state = 0;
  }
}
\end{lstlisting}
