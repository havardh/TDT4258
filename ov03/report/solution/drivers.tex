\subsection{Drivers}
The led driver and the button driver has a lot of similar code, mainly 
the initialization process and the termination process of the driver. 
They are both character devices that registers a memory region on the 
PIOB and registers itself as a character device, with major numbers and 
file operations like read and write. The following sections 
describe the implementation of the led driver, but it is the same for
the button driver.

\subsubsection{module init}
The leds and buttons driver have the init functions \textbf{leds\_init}
and \textbf{buttons\_init}, respectively.
The first thing that happens is allocation of a character device region
and assigning a mojor number to the device.
\begin{lstlisting}
result = alloc_chrdev_region ( &dev, leds_minor, NUM_DEVICES, "leds" );
leds_major = MAJOR ( dev );
\end{lstlisting}
If alloc\_chrdev\_region returns a negative number there is a problem getting
a major number to the device and the init method returns with an error.
If result is positive we build a dev\_t data item, 
representing the device based on the minor and major number, and requests memory region that we are going to use on the GPIO at the PIOB address.
If all goes well we initialize the \textit{per} and, 
\textit{oer} registers at piob (\textit{per} and \textit{puer}
for buttons), in order to be able to read and write from PIOB.
\begin{lstlisting}
dev = MKDEV ( leds_major, leds_minor );
result = (int) request_region ( AVR32_PIOB_ADDRESS, mem_quantum, "leds" );
// Initialize the leds
volatile avr32_pio_t *piob = &AVR32_PIOB;
piob->per |= 0xff;
piob->oer |= 0xff;
\end{lstlisting}